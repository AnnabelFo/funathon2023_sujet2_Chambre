---
title: "Sujet2-Etape1"
format: html
# embed-resources: true
# standalone: true
self-contained: true
toc: true
toc-depth: 3
number-sections: true
toc-location: left
css: styles.css
theme: united
editor: visual
output-file: Sujet2-Etape1.html
---

```{r setup, include=FALSE}
#| label: setup
#| echo: false

library(tidyverse) 
library(aws.s3)
library(sf)
library(RPostgreSQL)
library(janitor)
if (!"kableExtra" %in% installed.packages()) { install.packages("kableExtra") }
library(kableExtra)

# données -----------------------------------------------------------------
aws.s3::get_bucket("projet-funathon", region = "",  prefix = "2023/sujet2/diffusion/ign/rpg")

```

test commit

## Etape 1 : Première manipulation du RPG

### Je choisis un point sur la carte : <https://www.google.fr/maps>

=\> clic droit sur la carte + clic gauche sur les coordonnées (copiées dans le presse-papier)

J'indique un rayon en mètres pour sélectionner les parcelles autour du point

```{r}
#| label: choix coordonnées + rayon
#| echo: false
# coord_gmaps<- rstudioapi::showPrompt(title = "Collez les coordonnées", message = "coordonnées Gmaps", default = "")
coord_gmaps<-"46.46946179131805, -1.4932577154775046"
lat<-as.numeric(str_split(coord_gmaps,fixed(","),simplify = TRUE)[,1])
lon<-as.numeric(str_split(coord_gmaps,fixed(","),simplify = TRUE)[,2])
# rayon<-as.numeric(rstudioapi::showPrompt(title = "Rayon", message = "Rayon (en m)", default = ""))
rayon<-5000

# création d'une table sf «point» avec les coordonnées saisies
# transformation des coordonnées en syst de proj 2154 (Lambert II - Français) 
point<-data.frame(lon,lat,rayon) %>% 
  st_as_sf(coords = c("lon","lat"),crs = "EPSG:4326") %>%
  mutate(coord_pt_gps=st_as_text(geometry)) %>% 
  st_transform("EPSG:2154") %>% 
  st_sf() %>% clean_names() %>% 
  rename(geom=geometry)

# st_crs(point)
# st_geometry_type(point)
# plot(point)
```

La table des parcelles agricoles 2021 se trouve sur un serveur PostgreSQL/PostGIS.

### Je me connecte au serveur PostgreSQL avec le mot de passe disponible sur Onyxia/Mes services/PostgreSQL/Read me

```{r}
#| echo: false
#| label: connection PostGis

# le mot de passe est stocké dans un secret Vault

# postgresql_password <- rstudioapi::askForPassword(prompt = "Entrez le password PostgreSQL")
postgresql_password <- "1tfawt3nj7fgzo3w7cma"
  
# Connection à PostgreSQL
cnx <- dbConnect(PostgreSQL(),
                user = "projet-funathon",
                password = postgresql_password,
                host = "postgresql-438832",
                dbname = "defaultdb",
                port = 5432,
                options="-c search_path=rpg,public") # specify what schema to connect to
                 
```

### je lance une requête SQL pour sélectionner les parcelles situées autour de mon point dans le rayon choisi.

```{r}
#| echo: false
#| label: requete SQL selection parcelles

# suppression de la table «point» si elle existe
dbSendQuery(cnx,"DROP TABLE IF EXISTS rpg.point CASCADE;")

# écriture de la table point dans la base PostGis
write_sf(point, cnx, append = T)

# ajout d'une clé primaire
dbSendQuery(cnx,"ALTER TABLE rpg.point ADD CONSTRAINT point_pkey PRIMARY KEY(coord_pt_gps);")

# ajout d'un index
dbSendQuery(cnx,"CREATE INDEX ON rpg.point USING gist(geom);")
# dbExecute(cnx,"CREATE INDEX ON rpg.point USING gist(geom);")

# 3 - Exécution de la requête de découpage du RPG autour du point sur PostGis  -------

dbSendQuery(cnx,"DROP TABLE IF EXISTS rpg.parc_prox CASCADE;")

dbSendQuery(cnx,"CREATE TABLE rpg.parc_prox AS
	SELECT row_number() OVER () AS row_id, p.coord_pt_gps, p.rayon, r.*  
	FROM rpg.point p, rpg.parcelles r 
	WHERE ST_DWithin(p.geom,r.geom,p.rayon);")

# ajout d'une clé primaire
dbSendQuery(cnx,"ALTER TABLE rpg.parc_prox ADD CONSTRAINT parc_prox_pk PRIMARY KEY(id_parcel);")

# ajout d'un index
dbSendQuery(cnx,"CREATE INDEX parc_prox_geom_idx ON rpg.parc_prox USING gist(geom);")


# 4 - Téléchargement des parcelles proches sous R-------------------------------

# parc_prox<-read_sf(cnx,parc_prox)

parc_prox<-st_read(cnx, query="select * from rpg.parc_prox;")

```

### J'affiche les parcelles autour de mon point (prévoir un leaflet ?)

```{r}
#| echo: false
#| label: affichage parcelles

plot(st_geometry(parc_prox))
plot(st_geometry(point),add = T,col = "red")
```

### Quelle est la structure des parcelles agricoles autour de mon point ?

```{r }
#| echo: false
#| label: lecture libellés groupes cultures

lib_group_cult<-s3read_using(FUN = read_csv2, 
                         object = "2023/sujet2/diffusion/ign/rpg/REF_CULTURES_GROUPES_CULTURES_2020.csv",
                         col_types = cols(.default = col_character()),
                         bucket = "projet-funathon",
                         opts = list("region" = "")) %>% 
  select(CODE_GROUPE_CULTURE,LIBELLE_GROUPE_CULTURE) %>% 
  distinct(CODE_GROUPE_CULTURE,.keep_all=T) %>% 
  rename (code_group_culture=CODE_GROUPE_CULTURE,libelle_groupe_culture=LIBELLE_GROUPE_CULTURE)

```

```{r}
#| echo: false
#| label: stats sur les groupes de cultures 
#| tbl-cap: Structure des cultures 

t1 <- parc_prox %>% st_drop_geometry() %>% count(code_group) %>% 
  add_tally(n) %>% 
  mutate(n_pct=round(100*n/nn,1)) %>% 
  select(-nn) %>% rename(n_parcelles=n) %>%
  # adorn_totals() %>% 
cbind(
  # comptage des surfaces
parc_prox %>% st_drop_geometry() %>% count(code_group,wt=surf_parc) %>% 
      add_tally(n) %>% 
      mutate(surf_pct=round(100*n/nn,1)) %>%
      select(-nn) %>%  
      rename(surf_parc_ha=n) %>% select(surf_parc_ha, surf_pct) # %>% 
       # adorn_totals()
) %>% left_join(lib_group_cult,by=c("code_group"="code_group_culture")) %>% 
  select(code_group,libelle_groupe_culture,everything()) %>% 
  arrange(as.numeric(code_group)) %>% adorn_totals() %>% 
  mutate(taille_moy_parc=round(surf_parc_ha/n_parcelles,1))

kable(t1,
format="html"
,format.args = list(decimal.mark = ",", big.mark = " ")
,booktabs = TRUE) %>%
  kable_styling(font_size = 15) %>% 
  gsub("font-size: initial !important;",
       "font-size: 20pt !important;",.)%>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  row_spec(nrow(t1), bold = T, color = "white", background = "grey")

rm(t1)
```

### Comparaison avec la structure départementale et et nationale

```{r}
#| label: comparaison structure départementale et nationale 
#| echo: false
#| tbl-cap: Structure des cultures 

# jointure spatiale avec la couche commune pour récupérer le département où tombe le point

# ouvrir la couche des communes
# com <- s3read_using(
#   FUN = sf::read_sf,
#   layer = "COMMUNE_2021",
#   object = "2023/sujet2/diffusion/ign/COMMUNE_2021.gpkg",
#   bucket = "projet-funathon",
#   opts = list("region" = "")) %>% clean_names()

# jointure
# df<-point %>% st_join(com) %>% st_drop_geometry() %>% select(insee_dep) 
# dep_pt<-df[1,1]
# rm(df)

# sinon sélection du département regroupant la plus grande surface agricole
# cas où le cercle recouvre plusieurs départements
df<-parc_prox %>% st_drop_geometry() %>% 
  count(insee_dep,wt=surf_parc) %>% 
  arrange(desc(n))
dep_pt<-df[1,1]
rm(df)

# calcul des % surfaces autour du point
stat_pt <- parc_prox %>% st_drop_geometry() %>% 
  count(code_group,wt=surf_parc) %>% add_tally(n) %>% 
  mutate(pct_surf_local=round(100*n/nn,1)) %>%
  select(code_group, pct_surf_local) 

# récup des % surfaces départementales
stat_dep_pt<-s3read_using(
  FUN=readr::read_rds,
  object = "2023/sujet2/diffusion/resultats/stat_group_cult_by_dep.rds",
  bucket = "projet-funathon",
  opts = list("region" = "")) %>% 
  filter(insee_dep %in% dep_pt) %>% 
  select(insee_dep,code_group,libelle_groupe_culture,pct_surf) %>% 
  rename(pct_surf_dep = pct_surf)

# récup des % surfaces nationales
stat_fm<-s3read_using(
  FUN=readr::read_csv,
  object = "2023/sujet2/diffusion/resultats/stat_group_cult_fm.csv",
  col_types = cols(code_group = col_character()),
  bucket = "projet-funathon",
  opts = list("region" = "")) %>% 
 select(code_group,libelle_groupe_culture,pct_surf) %>% 
  rename(pct_surf_fm = pct_surf)

stat_comp<-stat_fm %>% 
  left_join(stat_dep_pt %>% select(code_group, pct_surf_dep),by="code_group") %>% 
  left_join(stat_pt,by="code_group") %>% 
  select(libelle_groupe_culture,pct_surf_local,pct_surf_dep,pct_surf_fm) %>% 
  arrange(desc(pct_surf_local)) %>% adorn_totals() 

kable(stat_comp)
```

### Graphique

```{r}
#| label: faire un graphique comparant les structures
#| echo: false
#| fig-cap: différences de structure locale, departementale, nationale  

tab<-stat_comp %>% filter(libelle_groupe_culture!="Total") %>% 
  rename(local=pct_surf_local, departement=pct_surf_dep, france=pct_surf_fm)
tab_piv<-tab %>% pivot_longer(!libelle_groupe_culture) 
#tab_piv<-tab_piv %>% coalesce(value,0L)  
tab_piv[is.na(tab_piv)] <- 0


p<-ggplot(tab_piv, 
          aes(x = reorder(libelle_groupe_culture,+value), y = value, fill=name)) + geom_col(position = "dodge") +
  labs(title="Surface par culture", x="Culture", y = "%")+
  theme_classic()

p+coord_flip()
```

## Création d'un dashboard de visualisation

On souhaiterait intégrer les analyses faites ci-dessus à un tableau de bord qui offrirait des visualisations interactives. Une solution est d'utiliser `Shiny`, une librairie qui permet la création de telles applications avec `R` notamment.

Une application `Shiny` simple a deux composants principaux :

- Un objet d'interface utilisateur (UI) qui contrôle la disposition et l'apparence du tableau de bord ;
- Une fonction serveur qui contient les instructions nécessaires au fonctionnement de l'application.

Lorsque ces deux composants sont définis, l'application est lancée à l'aide d'une simple instruction `runApp`. Ici, on aimerait bien aller vers une première version de tableau de bord, qui afficherait au départ une carte interactive et laisserait aussi à l'utilisateur de choisir un rayon. Une fois ce rayon choisi et un point sélectionné grâce à un clic sur la carte, on souhaiterait (comme affiché ci-dessous) :

- Afficher sur la carte les parcelles se situant à une distance inférieure au rayon choisi du point spécifié ;
- Afficher des statistiques sur les parcelles en questions. 

![Shiny screenshot](img/shiny_screenshot.png)
Ainsi notre UI sera un objet [`fluidPage`](https://shiny.posit.co/r/reference/shiny/1.3.1/fluidpage) composé de trois éléments, et dans la fonction de serveur il y aura deux évènements distincts à [observer](https://shiny.posit.co/r/reference/shiny/1.0.1/observeevent). Pour développer l'application, créez un répertoire `my_app` et à l'intérieur 3 fichiers, un fichier `ui.R`, un fichier `server.R` et un fichier `utils.R` (dans lequel se trouveront les fonctions utilitaires).

## UI

Le fichier UI aura la forme suivante :

```{r}
library(shiny)

# Define UI
ui <- fluidPage(
  ...
)
```

A l'intérieur de la fonction `fluidPage` et grâce à la documentation de `Shiny`, ajoutez les 3 éléments qui constitueront le tableau de bord : un output de type "carte `leaflet`", un champ d'input numérique, et un output de type "table".

```{r}
library(shiny)

# Define UI
ui <- fluidPage(
  leafletOutput("map", height = 800),
  numericInput("buffer_radius", "Rayon (en km) :", value = 5),
  tableOutput("table")
)
```

## Serveur

Le code de la fonction serveur figure ci-dessous dans son intégralité, et l'objectif de cette partie va être d'implémenter dans `utils.R` les différentes fonctions appelées dans le code :

- `connect_to_db` : une fonction qui renvoie une connexion à la base de données ;
- `query_db` : une fonction qui interroge la base de données pour récupérer les parcelles se situant à l'intérieur d'un cercle de rayon `radius` d'un point défini par une latitude et une longitude ;
- `plot_surroundings` : une fonction qui prend en entrée la sortie de la fonction `query_db` et une carte `leaflet` et qui ajoute une couche comportant les polygones des parcelles concernées ;
- `compute_stats` : une fonction qui prend en entrée la sortie de la fonction `query_db` et renvoie des statistiques sur les parcelles concernées.

```{r}
library(shiny)
library(leaflet)


# Define server
server <- function(input, output) {
  
  # Render the map
  output$map <- renderLeaflet({
    leaflet() %>%
      addTiles("http://wxs.ign.fr/essentiels/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE=normal&TILEMATRIXSET=PM&FORMAT=image/jpeg&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}") %>%
      setView(lng = -1.4932577154775046, lat = 46.46946179131805, zoom = 12)
  })
  
  # Connect to database
  cnx <- connect_to_db()
  
  # Initialize a reactive value for storing the selected point
  selectedPoint <- reactiveValues(lat = NULL, lng = NULL)
  
  # Handle click event on the map
  observeEvent(input$map_click, {
    
    clickData <- input$map_click
    if (!is.null(clickData)) {
      # Store selected point
      selectedPoint$lat <- clickData$lat
      selectedPoint$lng <- clickData$lng
      
      buffer_radius <- input$buffer_radius
      sf <- query_db(cnx, selectedPoint$lat, selectedPoint$lng, buffer_radius)

      # Update the map with the marker at the selected point
      leafletProxy("map") %>%
        clearMarkers() %>%
        clearShapes() %>%
        addMarkers(lng = selectedPoint$lng, lat = selectedPoint$lat) %>%
        plot_surroundings(sf)
      
      # Computations on queried data
      df <- compute_stats(sf)
      
      # Update rendered table
      output$table <- renderTable({
        df
      })
    }
  })
  
  observeEvent(input$buffer_radius, {
    # Check if a point has been selected
    if (!is.null(selectedPoint$lat) && !is.null(selectedPoint$lng)) {
      # Perform computations based on the selected point and new radius
      buffer_radius <- input$buffer_radius
      sf <- query_db(cnx, selectedPoint$lat, selectedPoint$lng, buffer_radius)
      
      # Update the map with the new polygons
      leafletProxy("map") %>%
        clearShapes() %>%
        plot_surroundings(sf)
      
      # Computations on queried data
      df <- compute_stats(sf)
      
      # Update rendered table
      output$table <- renderTable({
        df
      })
    }
  })
}
```

Proposer une implémentation des fonctions `connect_to_db`, `query_db` et `compute_stats` décrites ci-dessus et utilisées dans la fonction "serveur".

**`connect_to_db`**

```{r}
#' Connection au serveur PostgreSQL. Le mot de passe doit être stocké dans la
#' variable d'environnement PASS_POSTGRESQL.
#' 
#' @returns Connexion au serveur.
connect_to_db <- function() {
  # Connection à PostgreSQL
  cnx <- dbConnect(Postgres(),
                   user = Sys.getenv("USER_POSTGRESQL"),
                   password = Sys.getenv("PASS_POSTGRESQL"),
                   host = "postgresql-758156.projet-funathon",
                   dbname = "defaultdb",
                   port = 5432,
                   check_interrupts = TRUE)
  
  return(cnx)
}
```

**`query_db`**

On souhaite implémenter la fonction suivante :

```{r}
#' Requête la table `parcelles` pour récupérer les parcelles qui se situent
#' dans un certain rayon autour d'un point repéré par une latitude et 
#' une longitude.
#' 
#' @param cnx Connexion à PostgreSQL.
#' @param lat Latitude.
#' @param lng Longitude.
#' @param radius Rayon.
#' @returns Objet `sf` avec les données des parcelles concernées.
query_db <- function(cnx, lat, lng, radius) {
  ...
}
```

On pourra notamment utiliser plusieurs fonctions PostGIS :

- [`ST_MakePoint`](https://postgis.net/docs/ST_MakePoint.html) qui permet de créer une géométrie POINT;
- [`ST_SetSRID`](https://postgis.net/docs/ST_SetSRID.html) qui permet de définir le système de coordonnées pour une géométrie;
- [`ST_Buffer`](https://postgis.net/docs/ST_Buffer.html) qui calcule un POLYGON ou un MULTIPOLYGON qui représente tous les points dont la distance par rapport à une géométrie/géographie est inférieure ou égale à une distance donnée;
- [`ST_Intersects`](https://postgis.net/docs/ST_Intersects.html) qui compare deux géométries et renvoie `true` si elles ont une intersection non-nulle;

ainsi que des fonction de la librairie `sf`.

```{r}
#' Requête la table `parcelles` pour récupérer les parcelles qui se situent
#' dans un certain rayon autour d'un point repéré par une latitude et 
#' une longitude.
#' 
#' @param cnx Connexion à PostgreSQL.
#' @param lat Latitude.
#' @param lng Longitude.
#' @param radius Rayon.
#' @returns Objet `sf` avec les données des parcelles concernées.
query_db <- function(cnx, lat, lng, radius) {
  # Les données spatiales sur PostgreSQL sont stockées en Lambert 93.
  # Pour faire le join on veut donc projeter les coordonnées `lat`` et `lng`
  postgis_crs <- "EPSG:2154"
  coordinates <- data.frame(lng = c(lng), lat = c(lat)) %>%
    st_as_sf(coords = c("lng", "lat"), remove = TRUE) %>%
    st_set_crs("EPSG:4326") %>%
    st_transform(postgis_crs)
  
  # Requête PostgreSQL
  query <- sprintf(
    "SELECT * FROM rpg.parcelles WHERE ST_Intersects(geom, ST_Buffer(ST_SetSRID(ST_MakePoint(%f, %f), 2154), %.0f));",
    st_coordinates(coordinates)[1],
    st_coordinates(coordinates)[2],
    radius*1000)
  
  # Récupération des résultats
  sf <- st_read(
    cnx,
    query = query
  )
  
  return(sf)
}
```

**`compute_stats`**

On souhaite implémenter la fonction suivante :

```{r}
#' Crée la table à afficher sur l'application grâce à des calculs sur les
#' données requêtées depuis PostgreSQL.
#' 
#' @param sf Données spatiales.
#' @returns data.frame à afficher.
compute_stats <- function(sf) {
  ...
}
```

qui calcule sur une table spatiale renvoyéer par la fonction `query_db` ...

```{r}
# Récupération des libellés des différentes cultures
lib_cult <- s3read_using(FUN = read_csv2,
                         object = "2023/sujet2/diffusion/ign/rpg/REF_CULTURES_GROUPES_CULTURES_2020.csv",
                         col_types = cols(.default = col_character()),
                         bucket = "projet-funathon",
                         opts = list("region" = "")) %>% clean_names()


lib_group_cult <- lib_cult %>% 
  select(code_groupe_culture, libelle_groupe_culture) %>% 
  distinct(code_groupe_culture, .keep_all=T)

lib_group_cult %>% kable()
```

```{r}
#' Crée la table à afficher sur l'application grâce à des calculs sur les
#' données requêtées depuis PostgreSQL.
#' 
#' @param sf Données spatiales.
#' @returns data.frame à afficher.
compute_stats <- function(sf) {
  df <- sf %>% 
    st_drop_geometry() %>%
    count(code_group, name = "parcelles_grp") %>%
    add_tally(parcelles_grp, name = "parcelles_tot") %>%
    mutate(pct_parcelles = round(100*parcelles_grp/parcelles_tot, 1)) %>%
    select(-parcelles_tot) %>%
    cbind(
      # Comptage des surfaces
      sf %>% 
        st_drop_geometry() %>%
        count(code_group, wt = surf_parc, name = "surface_grp") %>% 
        add_tally(surface_grp, name = "surface_tot") %>% 
        mutate(surface_pct = round(100*surface_grp/surface_tot, 1)) %>%
        select(-surface_tot) %>%
        select(surface_grp, surface_pct)
      ) %>% 
    left_join(lib_group_cult, by = c("code_group" = "code_groupe_culture")) %>% 
    select(code_group, libelle_groupe_culture, everything()) %>% 
    arrange(desc(surface_grp)) %>% 
    adorn_totals() %>% 
    mutate(mean_surface = round(surface_grp/parcelles_grp, 1))

  return(
    df %>%
      select(-code_group) %>%
      setNames(
        c(
          "Groupe de cultures",
          "Nombre de parcelles",
          "Pourcentage de parcelles",
          "Surface (ha)",
          "Surface (%)",
          "Surface moyenne d'une parcelle (ha)"))
  )
}
```

**`plot_surroundings`**

```{r}
#' Rajoute les données d'un objet `sf` sous forme de polygones à une
#' carte `leaflet`.
#' 
#' @param leaflet_proxy Carte.
#' @param sf Données spatiales.
#' @returns Carte enrichie.
plot_surroundings <- function(leaflet_proxy, sf) {
  # Transformation de la projection (WGS 84)
  sf <- sf %>% st_transform(4326)
  
  # Ajout des libellés des cultures
  sf <- sf %>% 
    left_join(lib_cult %>% select(-code_groupe_culture), by = c("code_cultu" = "code_culture")) 
  
  # Création des labels à afficher au passage de la souris sur la carte.
  labels <- sprintf("<strong>Identifiant de la parcelle : </strong>%s<br/>
                    <strong>Groupe culture : </strong>%s<br/>
                    <strong>Culture : </strong>%s<br/>
                    <strong>Surface (ha) : </strong>%s<br/>
                    <strong>Département : </strong>%s<br/>
                    <strong>Commune : </strong>%s<br/>",
                    sf$id_parcel,
                    sf$libelle_groupe_culture,
                    sf$libelle_culture,
                    sf$surf_parc,
                    sf$insee_dep,
                    sf$nom_com) %>%
    lapply(htmltools::HTML)

  return(
    leaflet_proxy %>%
    addPolygons(
      data = sf,
      fillColor = ~factpal(code_group),
      weight = 2,
      opacity = 1,
      color = "#ffd966",
      dashArray = "3",
      fillOpacity = 0.5,
      highlight = highlightOptions(
        weight = 5,
        color = "#A40000",
        dashArray = "",
        fillOpacity = 0.0,
        bringToFront = TRUE),
      label = labels,
      labelOptions = labelOptions(
        style = list("font-weight" = "normal", padding = "3px 8px"),
        textsize = "15px",
        direction = "auto",
        encoding="UTF-8"))
  )
}
```

```{r}
# Création d'une palette de couleurs associée au groupe de culture
pal <- brewer.pal(12, "Paired")
pal <- colorRampPalette(pal)(24)
factpal <- colorFactor(pal, lib_group_cult$code_groupe_culture)
```
